package burp;

import com.alibaba.fastjson2.JSON;
import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.List;

/**
 * 漏洞判断引擎 - 增强版，支持基于请求类型的判断逻辑
 */
@Slf4j
public class VulnerabilityDetectionEngine {

    private IExtensionHelpers helpers;
    // 各类安全关键词列表
    private List<String> generalSafeKeywords;
    private List<String> authSafeKeywords;
    private List<String> csrfSafeKeywords;
    private List<String> methodSafeKeywords;

    // 失败关键词列表
    private final String[] failureKeywords = {
            "404", "not found", "找不到页面", "不存在", "权限不足", "无权限",
            "拒绝访问", "access denied", "禁止访问", "forbidden", "unauthorized",
            "未授权", "请登录", "请先登录", "login required", "权限错误", "未登录",
            "无法访问", "cannot access", "没有权限", "insufficient privileges",
            "insufficient permissions", "permission denied", "error", "错误",
            "异常", "exception", "failed", "失败"
    };

    public VulnerabilityDetectionEngine(IExtensionHelpers helpers,
                                        List<String> generalSafeKeywords,
                                        List<String> authSafeKeywords,
                                        List<String> csrfSafeKeywords,
                                        List<String> methodSafeKeywords) {
        this.helpers = helpers;
        this.generalSafeKeywords = generalSafeKeywords;
        this.authSafeKeywords = authSafeKeywords;
        this.csrfSafeKeywords = csrfSafeKeywords;
        this.methodSafeKeywords = methodSafeKeywords;
    }

    /**
     * 漏洞判断结果类
     */
    public static class VulnerabilityResult {
        private boolean isVulnerable;
        private boolean needsConfirmation;
        private String reason;

        public VulnerabilityResult(boolean isVulnerable, boolean needsConfirmation, String reason) {
            this.isVulnerable = isVulnerable;
            this.needsConfirmation = needsConfirmation;
            this.reason = reason;
        }

        public boolean isVulnerable() { return isVulnerable; }
        public boolean isNeedsConfirmation() { return needsConfirmation; } // 使用与原代码一致的方法名
        public String getReason() { return reason; }
    }

    /**
     * 基于HTTP状态码进行初步判断
     */
    public boolean[] evaluateByStatusCode(int statusCode) {
        // 2xx状态码通常表示请求成功，可能存在漏洞
        boolean initialIsVulnerable = statusCode >= 200 && statusCode < 300;

        // 3xx重定向（除了302）、特定的4xx可能需要人工确认
        boolean initialNeedsConfirmation = statusCode >= 300 && statusCode < 400 && statusCode != 302;

        return new boolean[] {initialIsVulnerable, initialNeedsConfirmation};
    }

    /**
     * CSRF漏洞特定的状态码判断逻辑
     */
    public boolean[] evaluateCsrfByStatusCode(int statusCode, String method) {
        boolean isVulnerable = false;
        boolean needsConfirmation = false;

        // 对于修改类请求，如果返回2xx，很可能存在CSRF漏洞
        if (method.equalsIgnoreCase("POST") ||
                method.equalsIgnoreCase("PUT") ||
                method.equalsIgnoreCase("DELETE")) {

            if (statusCode >= 200 && statusCode < 300) {
                isVulnerable = true;
            }
            // 对于3xx重定向，需要人工确认，但302直接标记为安全
            else if (statusCode >= 300 && statusCode < 400) {
                if (statusCode != 302) {
                    needsConfirmation = true;
                }
            }
            // 对于403 Forbidden可能需要确认（可能是其他原因导致的禁止访问）
            else if (statusCode == 403) {
                needsConfirmation = true;
            }
            // 常见错误状态码直接判定为安全
        }

        return new boolean[] {isVulnerable, needsConfirmation};
    }

    /**
     * 不安全HTTP方法特定的状态码判断逻辑
     */
    public boolean[] evaluateUnsafeMethodByStatusCode(int statusCode, String method) {
        boolean isVulnerable = false;
        boolean needsConfirmation = false;

        if (method.equals("OPTIONS")) {
            // OPTIONS方法特殊处理在调用方完成，这里不做判断
        }
        else if (method.equals("TRACE")) {
            // TRACE方法的判断会在内容检查中完成
        }
        else {
            // 对于PUT、DELETE等方法
            if (statusCode >= 200 && statusCode < 300) {
                // 2xx状态码，可能存在漏洞
                isVulnerable = true;
            }
            else if (statusCode == 401 || statusCode == 403) {
                // 401/403表示需要认证/授权，配置可能正确
            }
            else if (statusCode == 404 || statusCode == 500 ||
                    statusCode == 502 || statusCode == 503 ||
                    statusCode == 504) {
                // 明确的错误状态码，直接判定为安全
                log.info("不安全HTTP方法测试: 状态码为 " + statusCode + " 直接判定为安全");
            }
            else if (statusCode != 405 && statusCode != 501) {
                // 非405（Method Not Allowed）或501（Not Implemented）可能需要确认
                needsConfirmation = true;
            }
        }

        return new boolean[] {isVulnerable, needsConfirmation};
    }

    /**
     * 基于响应内容关键字检查是否包含失败或安全关键词
     */
    public boolean[] evaluateByKeywords(byte[] response, List<String> safeKeywordsList) {
        if (response == null) {
            return new boolean[] {false, false};
        }

        // 检查是否包含失败关键词
        boolean containsFailure = containsFailureKeywords(response);

        // 检查是否包含安全关键词
        boolean containsSafe = containsMethodSafeKeywords(response, safeKeywordsList);

        return new boolean[] {containsFailure, containsSafe};
    }

    /**
     * TRACE方法特定的内容检查
     */
    public boolean checkTraceVulnerability(int statusCode, byte[] response, String url) {
        if (statusCode >= 200 && statusCode < 300 && response != null) {
            // 获取响应体
            IResponseInfo responseInfo = helpers.analyzeResponse(response);
            int bodyOffset = responseInfo.getBodyOffset();
            String responseBody = new String(Arrays.copyOfRange(response, bodyOffset, response.length));

            // 如果TRACE方法成功返回并包含原始请求，存在XST漏洞
            return responseBody.contains("TRACE") && responseBody.contains(url);
        }
        return false;
    }

    /**
     * OPTIONS方法特定的头部检查
     */
    public boolean checkOptionsVulnerability(byte[] response) {
        if (response == null) {
            return false;
        }

        IResponseInfo responseInfo = helpers.analyzeResponse(response);
        List<String> headers = responseInfo.getHeaders();

        // 检查Allow头是否包含危险方法
        for (String header : headers) {
            if (header.toLowerCase().startsWith("allow:")) {
                String allowHeader = header.toLowerCase();
                return allowHeader.contains("put") ||
                        allowHeader.contains("delete") ||
                        allowHeader.contains("trace");
            }
        }

        return false;
    }

    /**
     * 基于响应内容相似度进行判断
     */
    public int evaluateBySimilarity(byte[] response1, byte[] response2) {
        return compareResponses(response1, response2);
    }

    /**
     * 综合判断未授权访问漏洞
     */
    public VulnerabilityResult detectAuthVulnerability(int statusCode, byte[] response) {

        if (isLikelyJsonResponse(response)) {
            return new VulnerabilityResult(true, false, "响应为JSON格式，可能存在敏感信息泄露");
        }

        // 1. 基于状态码判断
        boolean[] statusCodeResult = evaluateByStatusCode(statusCode);
        boolean isVulnerable = statusCodeResult[0];
        boolean needsConfirmation = statusCodeResult[1];
        String reason = "基于状态码" + statusCode + "的初步判断";

        // 2. 基于关键词判断
        if (response != null) {
            boolean[] keywordResult = evaluateByKeywords(response, authSafeKeywords);
            boolean containsFailure = keywordResult[0];
            boolean containsSafe = keywordResult[1];

            if (containsSafe) {
                isVulnerable = false;
                needsConfirmation = false;
                reason = "响应包含安全关键词，判定为安全";
                log.info("未授权访问测试: 状态码为 " + statusCode + " 但响应包含安全关键词, 标记为安全");
            }
            else if (containsFailure && isVulnerable) {
                isVulnerable = false;
                needsConfirmation = true;
                reason = "响应包含失败关键词，需要人工确认";
                log.info("未授权访问测试: 状态码为 " + statusCode + " 但响应包含失败关键词, 标记为需要确认");
            }
        }

        return new VulnerabilityResult(isVulnerable, needsConfirmation, reason);
    }

    /**
     * 综合判断CSRF漏洞
     */
    public VulnerabilityResult detectCsrfVulnerability(int statusCode, byte[] response, String method) {
        // 1. 基于CSRF特定的状态码判断

        if (isLikelyJsonResponse(response)) {
            return new VulnerabilityResult(true, false, "响应为JSON格式，可能存在敏感信息泄露");
        }

        boolean[] statusCodeResult = evaluateCsrfByStatusCode(statusCode, method);
        boolean isVulnerable = statusCodeResult[0];
        boolean needsConfirmation = statusCodeResult[1];
        String reason = "基于状态码" + statusCode + "和请求方法" + method + "的初步判断";

        // 2. 基于关键词判断
        if (response != null && (isVulnerable || needsConfirmation)) {
            boolean[] keywordResult = evaluateByKeywords(response, csrfSafeKeywords);
            boolean containsFailure = keywordResult[0];
            boolean containsSafe = keywordResult[1];

            if (containsSafe) {
                isVulnerable = false;
                needsConfirmation = false;
                reason = "响应包含安全关键词，判定为安全";
                log.info("CSRF测试: 状态码为 " + statusCode + " 但响应包含安全关键词, 标记为安全");
            }
            else if (containsFailure) {
                isVulnerable = false;
                needsConfirmation = true;
                reason = "响应包含失败关键词，需要人工确认";
                log.info("CSRF测试: 状态码为 " + statusCode + " 但响应包含失败关键词, 标记为需要确认");
            }
        }

        return new VulnerabilityResult(isVulnerable, needsConfirmation, reason);
    }

    /**
     * 综合判断不安全HTTP方法漏洞
     */
    public VulnerabilityResult detectUnsafeMethodVulnerability(int statusCode, byte[] response,
                                                               String method, String url) {

        if (isLikelyJsonResponse(response)) {
            return new VulnerabilityResult(true, false, "响应为JSON格式，可能存在敏感信息泄露");
        }

        boolean isVulnerable = false;
        boolean needsConfirmation = false;
        String reason = "基于方法" + method + "和状态码" + statusCode + "的初步判断";

        // 1. 基于方法类型的特殊判断
        if (method.equals("OPTIONS")) {
            // OPTIONS方法特殊处理
            if (checkOptionsVulnerability(response)) {
                needsConfirmation = true;
                reason = "OPTIONS响应允许危险HTTP方法，需要确认";
            }
        }
        else if (method.equals("TRACE")) {
            // TRACE方法特殊处理
            if (checkTraceVulnerability(statusCode, response, url)) {
                isVulnerable = true;
                reason = "TRACE方法返回了请求内容，存在XST漏洞";
            }
        }
        else {
            // 其他方法使用通用判断
            boolean[] statusCodeResult = evaluateUnsafeMethodByStatusCode(statusCode, method);
            isVulnerable = statusCodeResult[0];
            needsConfirmation = statusCodeResult[1];
        }

        // 2. 基于关键词判断
        if (response != null && (isVulnerable || needsConfirmation)) {
            boolean[] keywordResult = evaluateByKeywords(response, methodSafeKeywords);
            boolean containsFailure = keywordResult[0];
            boolean containsSafe = keywordResult[1];

            if (containsSafe) {
                isVulnerable = false;
                needsConfirmation = false;
                reason = "响应包含安全关键词，判定为安全";
                log.info("不安全HTTP方法测试: 状态码为 " + statusCode + " 但响应包含安全关键词, 标记为安全");
            }
            else if (containsFailure && isVulnerable) {
                isVulnerable = false;
                needsConfirmation = true;
                reason = "响应包含失败关键词，需要人工确认";
                log.info("不安全HTTP方法测试: 状态码为 " + statusCode + " 但响应包含失败关键词, 标记为需要确认");
            }
        }

        return new VulnerabilityResult(isVulnerable, needsConfirmation, reason);
    }

    /**
     * 综合判断越权漏洞（基于相似度）
     */
    public VulnerabilityResult detectPrivilegeEscalationVulnerability(int statusCode, byte[] response,
                                                                      byte[] originalResponse, int similarity) {
        boolean isVulnerable = false;
        boolean needsConfirmation = false;
        String reason = "";

        if (isLikelyJsonResponse(response)) {
            return new VulnerabilityResult(true, false, "响应为JSON格式，可能存在敏感信息泄露");
        }

        // 1. 检查是否包含安全关键词
        boolean[] keywordResult = evaluateByKeywords(response, generalSafeKeywords);
        boolean containsFailure = keywordResult[0];
        boolean containsSafe = keywordResult[1];

        if (containsSafe) {
            reason = "响应包含安全关键词，判定为安全";
            log.info("越权测试: 响应包含安全关键词, 标记为安全");
        }
        else if (statusCode >= 200 && statusCode < 300) {
            // 2xx状态码，进一步判断
            if (!containsFailure) {
                // 检查响应内容相似度
                if (similarity > 70) {
                    isVulnerable = true;
                    reason = "响应状态码为" + statusCode + "，内容相似度为" + similarity + "%，可能存在漏洞";
                } else {
                    needsConfirmation = true;
                    reason = "响应状态码为" + statusCode + "，但内容相似度低(" + similarity + "%)，需要确认";
                }
            } else {
                needsConfirmation = true;
                reason = "响应状态码为" + statusCode + "，但包含失败关键词，需要确认";
            }
        }
        else if (statusCode >= 300 && statusCode < 400 && statusCode != 302) {
            // 重定向（除了302）需要确认
            needsConfirmation = true;
            reason = "响应状态码为" + statusCode + "（重定向），需要确认";
        }
        else {
            // 其他状态码判定为安全
            reason = "响应状态码为" + statusCode + "，判定为安全";
        }

        return new VulnerabilityResult(isVulnerable, needsConfirmation, reason);
    }

    // 以下是辅助方法，与之前相同
    private boolean containsFailureKeywords(byte[] response) {
        // 实现同前
        if (response == null) {
            return false;
        }

        // 获取响应体
        IResponseInfo responseInfo = helpers.analyzeResponse(response);
        int bodyOffset = responseInfo.getBodyOffset();
        String responseBody = new String(Arrays.copyOfRange(response, bodyOffset, response.length));
        String lowerResponseBody = responseBody.toLowerCase();

        for (String keyword : failureKeywords) {
            if (lowerResponseBody.contains(keyword.toLowerCase())) {
                return true;
            }
        }

        return false;
    }

    private boolean containsMethodSafeKeywords(byte[] response, List<String> keywords) {
        // 实现同前
        if (response == null || keywords == null || keywords.isEmpty()) {
            return false;
        }

        // 获取响应体
        IResponseInfo responseInfo = helpers.analyzeResponse(response);
        int bodyOffset = responseInfo.getBodyOffset();
        String responseBody = new String(Arrays.copyOfRange(response, bodyOffset, response.length));
        String lowerResponseBody = responseBody.toLowerCase();

        for (String keyword : keywords) {
            if (lowerResponseBody.contains(keyword.toLowerCase())) {
                return true;
            }
        }

        return false;
    }

    private int compareResponses(byte[] response1, byte[] response2) {
        // 实现同前
        if (response1 == null || response2 == null) {
            return 0;
        }

        // 获取响应体
        IResponseInfo responseInfo1 = helpers.analyzeResponse(response1);
        IResponseInfo responseInfo2 = helpers.analyzeResponse(response2);

        int bodyOffset1 = responseInfo1.getBodyOffset();
        int bodyOffset2 = responseInfo2.getBodyOffset();

        byte[] body1 = Arrays.copyOfRange(response1, bodyOffset1, response1.length);
        byte[] body2 = Arrays.copyOfRange(response2, bodyOffset2, response2.length);

        // 如果响应体长度差异过大，可能不相似
        if (Math.abs(body1.length - body2.length) > body1.length * 0.3) {
            return 30; // 30% 相似度
        }

        // 简单比较: 计算相同字节的百分比
        int minLength = Math.min(body1.length, body2.length);
        int maxLength = Math.max(body1.length, body2.length);
        int sameBytes = 0;

        for (int i = 0; i < minLength; i++) {
            if (body1[i] == body2[i]) {
                sameBytes++;
            }
        }
        return (int) ((sameBytes * 100.0) / maxLength);
    }
    private boolean isLikelyJsonResponse(byte[] response) {
        if (response == null || response.length == 0) {
            return false;
        }

        try {
            IResponseInfo responseInfo = helpers.analyzeResponse(response);
            int bodyOffset = responseInfo.getBodyOffset();
            String responseBody = new String(Arrays.copyOfRange(response, bodyOffset, response.length)).trim();

            // JSON 判断逻辑（避免过短干扰）
            if (responseBody.length() < 10) {
                return false;
            }

            // 使用 Fastjson2 的 isValid 判断
            return JSON.isValid(responseBody);
        } catch (Exception e) {
            return false;
        }
    }
}